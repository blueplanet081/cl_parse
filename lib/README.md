# cl_parse -- コマンドラインパーサー

## 紹介
コマンドラインのオプション、オプション引数を解析するメソッドを提供します。  
Pythonで記述するコマンドライン・プログラムに組み込んで使うものです。  
</br>

## 動作環境

* Python 3.8以降で動きます。
  - 作成と主なテストは Python 3.8 を使用しています。
  - 一か所「:=」演算子を使用しているので、3.7以前では動きません。そこだけ書き換えれば 3.7 でも動くと思いますが、テストしていません。
  - Enum を使っているので、3.6より古い環境では絶対に動きません。
* Windows10/11のPowerSheel、UbuntuのBash、MacOSのBash/zsh上で動作を確認しています。

</br>

## 作成経緯

CLIベースのコマンドを試作／製作するとき、起動オプションの処理を手軽に記述したかった。Python学習も兼ねて作成しています。  
標準ライブラリ argparseの仕様を一部参考にした部分もありますが、もともとこのライブラリの使い方が分からなかった（私には難解だった）ので、もっと簡単なものを、と思って作っています。

</br>

## 特徴（宣伝）

- オプション情報を配列で定義するだけなので、手軽に（ビジュアルに？）利用できます。
- オプション引数は指定のデータ型に変換されるので、プログラム内で容易に（改めて変換したり、型チェックをすることなく）使えます。
- データ型の指定は、ユーザー側で定義することもできます。（補助関数があります）
- 入力エラー時は、エラーメッセージ文字列とともにステータスに設定されます。その後の動作はユーザープログラム（呼び出し側のプログラム）に任されます。（argparseと最も違うところかも？）
- エラーメッセージ文字列は、ユーザー側で再定義可能です。
- usage:を表示したり作成したりする機能はありませんが、オプション一覧はそれなりに生成する機能があります。
- コマンド引数の後ろにオプションを入力するパターンとか、わりといろいろ対処できるようにしたつもりです。
- Windows環境では、解析に先立ってワイルドカード展開、~展開をします。Unix/Linux上と似たような動きで使えます。（ブレース展開は現段階ではサポートしていません）
- コマンドラインの指定により、オプション情報の設定内容や解析結果などを表示するデバッグ機能があります。

</br>

## **ファイル構成**

ファイル名                    | 内容
------------------------------|----
lib/cl_parse.py               | cl_parse本体（使うのに必要なのはこのファイルだけです）
lib/cl_parse_debugmodule.py   | cl_parse用デバッグモジュール
lib/README.md                 | このドキュメント
lib/cl_parse.md               | もう少し詳しい説明
---               |---
ptree.py          | miniparse使用サンプル。いわゆる treeコマンドの試作版です。
e2_path.py        | ptree.pyが呼び出している自作ライブラリ（添付用簡易版）
mp_sample01.py    | 一番シンプルなサンプル
mp_sample02.py    | エラー時にユーザ側で処理するサンプル
mp_sample03.py    | Usage:情報とか、ユーザ定義するサンプル
mp_sample04.py    | 区切りモードのサンプル
mp_sample04b.py   | 区切りながら最後まで解析するサンプル
mp_sample04c.py   | 区切りながら、その都度リセットして最後まで解析するサンプル

</br>

## **履歴**

バージョン   |日付     |変更箇所        | コメント 
------------|----------|---------------|------
0.9くらい   |2021/11/23|               |いちおう完成


</br>

---

## **使い方（超簡易版）**

```py
import sys
from lib import cl_parse as cl

options = [
        ["help", "-h, --help", "使い方を表示する", None],
        ["all", "-a, --all", "すべて出力"],
        ["date", "-d, --date", "対象日//<年/月/日>", cl.strptime('%Y/%m/%d')],
        ["size", "-s, --size", "表示サイズを指定する//<縦x横>",
                               cl.sepalate_items(type=int, sep='x', count=0)],
]

# cl_parse 呼び出し（解析実行）
args = sys.argv
op = cl.Parse(args, options, debug=True)
```

</br>

 > 1. cl_parse を importする。
 > 2. オプション情報を定義する。
 > 3. 解析するコマンドライン、オプション情報で、*\<cl_parse\>.* **Parse()** を呼び出す。

</br>

---

```py
# 解析エラー時の処理は自前で行う
if op.is_error:
    print(op.get_errormessage(1), file=sys.stderr)
    print()
    print("オプション一覧", file=sys.stderr)
    cl.tabprint(op.get_optionlist(), file=sys.stderr)
    exit(1)
```

</br>

  1. 解析エラー時には、 *\<option\>.* **is_error** が **True** になる。その後の動作はユーザープログラム側に任される。
  2. 解析エラーの理由は、*\<option\>.* **get_errormessage()** で取得する。
  3. 定義されたオプション情報の一覧を、*\<option\>.* **get_optionlist()** で取得できる。
  4. *\<cl_parse\>.* **tabprint()** は、一覧表を表示するためのサービス関数。

</br>

---

```py
# help情報の表示も自前
if op.OPT_help.isEnable:       # 使い方を表示する
    print("これは cl_parse のサンプルプログラムです。\n")
    print("オプション一覧")
    cl.tabprint(op.get_optionlist())
    exit()
```

</br>

  1. オプションに -h、--help などが指定された場合の、オプション情報の定義やhelp情報の表示もユーザープログラム側に任される。
  2. オプションが指定された時の判断（上記で *\<option\>.* **OPT_help.isEnable**）は、次項を参照。
  3. オプション情報の一覧の取得や表示は、前項を参照。

</br>

---

```py
# 解析結果
if op.OPT_all.isEnable:        # すべて出力
    print("オプション 'all' が指定されました。")

if op.OPT_date.isEnable:       # 対象日
    print("オプション 'date' が指定されました。")
    print(f'    {op.OPT_date.value=}')
    print()

if op.OPT_size.isEnable:       # 表示サイズを指定する
    print("オプション 'size' が指定されました。")
    print(f'    {op.OPT_size.value=}')
    print()
```


</br>

  1. オプションに -h、--help などが指定された場合の、オプション情報の定義やhelp情報の表示もユーザープログラム側に任される。
  2. オプションが指定された時の判断（上記で *\<option\>.* **OPT_help.isEnable**）は、次項を参照。
  3. オプション情報の一覧の取得や表示は、前項を参照。

</br>

---


## コマンドラインの構成とか、言葉の定義とかルール
注）ここで記述している内容は、本モジュールでのコマンドラインの扱いで、オフィシャルなものとかではありません。

</br>

### コマンドラインの構成

コマンド名 -a -b -c -d オプション引数 --version --output=オプション引数2 コマンド引数 コマンド引数2

-a、-b、-c、-d １文字オプション（'a'、'b'、'c'、'd' オプション文字）
--version、--output  ロング名オプション（version、output　オプション文字列）


### オプションのルール
- すべてのオプションは省略可
- オプションの指定順位は任意 </br>
　→ '-a -b -c --version' でも、'-b --version -a -c' でも、'--version -b -c -a' でも同じ
</br>
</br>

### １文字オプションのルール
- オプション文字は英数字１文字。
- １文字オプションがオプション引数をとるときは、オプションの直後に続けて指定、または空白をおいて指定する。</br>
　→ -d オプション引数、または -dオプション引数
- 複数の１文字オプションは、個別に入力しても良いし、- の後に続けて指定しても良い。</br>
　→ -a -b -c と、-abc、-a -bc、-ac -b などすべて同じ
- ただし、引数付き１文字オプションは、続けて指定する場合は一連の最後に指定する</br>
　→ -abd オプション引数、 -cdオプション引数 -ab など（-d がオプション引数必須の場合）。
- 引数付き１文字オプションは、オプション引数は省略不可。
</br>
</br>

### ロング名オプションのルール
- ロング名オプションのオプション文字列は、一意に判別できる限り省略して指定できる。
　→ --version、--verboseの２つのオプションがある時、'version'は、'versio'、'versi'、'vers'と省略できる。
- ロング名オプションのオプション引数は、オプション文字列の後の'='に続けて指定する。または空白をおいて指定する。
- オプション引数が省略可能なロング名オプションの場合、空白をおいて指定は不可。
</br>
</br>

### コマンド引数のルール
- 頭に'-'（ハイフン）が付かない文字、または文字列で、前記のオプション引数に該当しない単独文字、または文字列は、コマンド引数として認識される。
</br>
</br>

### 例外ルール
- '--'（ハイフン２つ）のみの文字列が存在した場合、その次の単独文字、または文字列は先頭に'-'（ハイフン）が付いていても強制的にオプション引数、またはコマンド引数と判断される。</br>
　→ -ab --version の場合、-a -b --version はすべて１文字、またはロング名オプション</br>
　→ -ab -- --version の場合、--version はコマンド引数、またはオプション引数（-b が引数付き１文字オプションの場合）
</br>
</br>

### 例外ルール２
- '-'（ハイフンひとつ）のみの文字が単独で存在した場合、現在はそのままコマンド引数、またはオプション引数と判断する。（後に仕様変更の可能性がある）
</br>
</br>

### ワイルドカード展開ルール
- コマンドラインの文字列中に「ワイルドカード」と判断される文字または文字列が含まれている場合、コマンドラインの解析に先立ってワイルドカードが展開される。
</br>
</br>

### ワイルドカード展開の抑制ルール
ワイルドカード展開をしたくない場合は、各文字列毎に、以下の手段で抑制できる。
  - 各文字列の頭に '\\' バックスラッシュを付ける。コマンドライン解析時は、バックスラッシュは削除される。
```
    → 「\*.py」 はワイルドカード展開されず、「*.py」として解釈される。
```
  - 各文字列をシングルクォートで囲む。コマンドライン解析時は、シングルクォートは削除される。
```
    → 「'*.py'」はワイルドカード展開されず、「*.py」として解釈される。
```
  - ただし、Windows環境では頭にスペースを一つ付けてシングルクォートで囲む。コマンドライン解析時は、シングルクォートとスペースは削除される。
```
    → 「' *.py'」はワイルドカード展開されず、「*.py」として解釈される（Windowsの場合）。
```

