<!-- omit in toc -->
# cl_parse -- コマンドラインパーサー
<!-- omit in toc -->
## 内容
- [概要](#概要)
  - [紹介](#紹介)
  - [動作環境](#動作環境)
  - [作成経緯](#作成経緯)
  - [特徴（宣伝）](#特徴宣伝)
  - [**ファイル構成**](#ファイル構成)
  - [**履歴**](#履歴)
- [**紹介**](#紹介-1)
  - [プログラム例](#プログラム例)
    - [サンプルプログラム（sample01.py）](#サンプルプログラムsample01py)
    - [実行例１](#実行例１)
    - [実行例２](#実行例２)
    - [実行例３（入力エラー）](#実行例３入力エラー)
  - [サンプルプログラムの中身の説明](#サンプルプログラムの中身の説明)
    - [cl_parseモジュールのimport](#cl_parseモジュールのimport)
    - [オプション情報の定義](#オプション情報の定義)
    - [cl_parse 呼び出し（コマンドラインの解析）](#cl_parse-呼び出しコマンドラインの解析)
    - [入力エラー時の処理](#入力エラー時の処理)
    - [help情報指定時の処理](#help情報指定時の処理)
  - [解析エラー時の処理](#解析エラー時の処理)
  - [helpメッセージの表示](#helpメッセージの表示)
  - [解析結果の取得](#解析結果の取得)
- [超簡易版のサンプルプログラムと実行例](#超簡易版のサンプルプログラムと実行例)
  - [サンプルプログラム（sample01.pas）](#サンプルプログラムsample01pas)
  - [**実行例**](#実行例)
- [もう少し詳しい説明](#もう少し詳しい説明)
  - [オプション情報](#オプション情報)
    - [**オプション名**](#オプション名)
    - [**オプション文字列**](#オプション文字列)
    - [**オプションのコメント**](#オプションのコメント)
    - [**オプション、オプション引数の「振る舞い」の定義**](#オプションオプション引数の振る舞いの定義)

<br>

# 概要
## 紹介
Pythonで記述するデスクトップ・プログラムに組み込んで使うもので、コマンドラインのオプション、オプション引数を解析するメソッドを提供します。  
<br>

## 動作環境

 * Python 3.8以降で動きます。
   - 作成と主なテストは Python 3.8 を使用しています。
   - 3.7 でも動くと思いますが、テストしていません。
   - Enum や、新しい型ヒントなどを使っているので、3.6より古い環境では動きません。
 * Windows10/11のPowerSheel、UbuntuのBash、MacOSのBash/zsh上で動作を確認しています。

<br>

## 作成経緯

  - CLIベースのコマンドを試作／製作するとき、起動オプションの処理を手軽に記述したかった。
  - 標準ライブラリ argparseの仕様を一部参考にした部分もありますが、もともとこのライブラリの使い方が分からなかった（私には難解だった）ので、もっと簡単なものを、と思って作っています。
  - Python学習も兼ねてます。  

<br>

## 特徴（宣伝）

   - オプション情報を１オプションにつき１行の組（タプル）で定義するだけなので、手軽に見通し良く利用できます。
   - オプションが引数を持つ場合、引数は解析時に指定のデータ型に変換されるので、ユーザープログラム内で容易に（改めて変換したり、型チェックをすることなく）使えます。
   - オプション引数のデータ型、変換方法は、ユーザー側で定義を追加することができます。（補助関数があります）
   - 入力エラー時は、エラーメッセージ文字列とともにステータスが設定されます。その後の動作はユーザープログラム（呼び出し側のプログラム）に任されます。（argparseと最も違うところかも？）
   - エラーメッセージ文字列は、ユーザー側で再定義可能です。
   - usage:を自動作成したり、help指定時に自動的に表示したりする機能はありませんが、オプション一覧をそれなりに生成する機能があります。
   - Windows環境では、解析に先立ってワイルドカード展開、~展開をします。Unix/Linux上と似たような動きで使えます。（ブレース展開は現段階ではサポートしていません）
   - コマンドラインの指定により、オプション情報の設定内容や解析結果などを表示するデバッグ機能や、ユーザープログラム内でオプション情報を取得するためのコードを生成する補助機能があります。

<br>

## **ファイル構成**

| ファイル名                    | 内容                                                       |
| ----------------------------- | ---------------------------------------------------------- |
| lib/cl_parse.py               | cl_parse本体（使うのに必要なのはこのファイルだけです）     |
| lib/cl_parse_functions.py     | cl_parse用変換関数                                         |
| lib/cl_parse_debugmodule.py   | cl_parse用デバッグモジュール                               |
| ----------------------------- | --------------------------------------------------------   |
| README.md                     | このドキュメント                                           |
| options.md                    | コマンドラインの構成とか、言葉の定義とか                   |
| sample01.py                   | 一番シンプルなサンプル                                     |
| ptree.py                      | miniparse使用サンプル。いわゆる treeコマンドの試作版です。 |
| e2_path.py                    | ptree.pyが呼び出している自作ライブラリ（添付用簡易版）     |

<br>

## **履歴**

| バージョン | 日付      | 変更箇所 | コメント     |
| ---------- | --------- | -------- | ------------ |
| 1.0.0      | 2022/3/23 |          | いちおう完成 |


<br>


# **紹介**
## プログラム例
### サンプルプログラム（sample01.py）

``` py
# sample01.py  for cl_parse module
import sys
from lib import cl_parse as cl
from lib import cl_parse_functions as cf


# オプション情報の定義
options = [
        ("#オプション一覧"),
        ("help", "-h, --help", "使い方を表示する"),
        ("all", "-a, --all", "すべて出力"),
        ("name", "-n, --name", "使用者名を指定する//<名前>", str),
        ("count", "-c, --count", "数量を指定する//<数(整数)>", int),
        ("date", "-d, --date", "対象日//<YYYY/M/D>", cf.strptime('%Y/%m/%d')),
]

# cl_parse 呼び出し（コマンドラインの解析）
ps = cl.Parse(sys.argv, options, emessage_header="@stem", debug=True)

# 入力エラー時の処理
if ps.is_error:
    print(ps.get_errormessage(1), file=sys.stderr)
    print(file=sys.stderr)
    for line in ps.get_optionlist():
        print(line, file=sys.stderr)
    exit(1)

# help情報指定時の処理
if ps.OPT_help.isEnable:       # 使い方を表示する
    print("これは cl_parse のサンプルプログラムです。\n")
    for line in ps.get_optionlist():
        print(line)
    exit()

# 以下、ユーザープログラムの処理 ---------------------------
# 各オプション指定時の処理
if ps.OPT_all.isEnable:        # すべて出力
    print("オプション 'all' が指定されました。")

if ps.OPT_name.isEnable:       # 使用者名を指定する
    print("オプション 'name' が指定されました。")
    print(f'    {ps.OPT_name.value=}')
    print()

if ps.OPT_count.isEnable:       # 数量を指定する
    print("オプション 'count' が指定されました。")
    print(f'    {ps.OPT_count.value=}')
    print()

if ps.OPT_date.isEnable:       # 対象日
    print("オプション 'date' が指定されました。")
    print(f'    {ps.OPT_date.value=}')
    print()

# コマンド引数の取得
if len(ps.params):
    print("以下のコマンド引数が入力されました。")
    print(ps.params)
```

### 実行例１
```txt
> python3 sample01.py -h
これは cl_parse のサンプルプログラムです。

オプション一覧
-h, --help      : 使い方を表示する
-a, --all       : すべて出力
-n, --name <名前>       : 使用者名を指定する
-c, --count <数(整数)>  : 数量を指定する
-d, --date <YYYY/M/D>   : 対象日
```

### 実行例２
```txt
> python3 sample01.py --name=Taro --date=2022/4/1 SAMPLE
オプション 'name' が指定されました。
    ps.OPT_name.value='Taro'

オプション 'date' が指定されました。
    ps.OPT_date.value=datetime.datetime(2022, 4, 1, 0, 0)

以下のコマンド引数が入力されました。
['sample01.py', 'SAMPLE']
```

### 実行例３（入力エラー）
```txt
> python3 sample01.py --name=Taro --date=2022/4/ SAMPLE
sample01 E12: illegal argument specified for option --date=2022/4/
  -- time data '2022/4/' does not match format '%Y/%m/%d'

オプション一覧
-h, --help      : 使い方を表示する
-a, --all       : すべて出力
-n, --name <名前>       : 使用者名を指定する
-c, --count <数(整数)>  : 数量を指定する
-d, --date <YYYY/M/D>   : 対象日
```
<br>

## サンプルプログラムの中身の説明
### cl_parseモジュールのimport
```py
import sys
from lib import cl_parse as cl
from lib import cl_parse_functions as cf
```

  * ここでは、cl_parseモジュールが ```./lib``` ディレクトリ内にあることを想定しています。
  * ```cl``` とか ```cf``` とかの「別名」はお好みで読み替えて（付け替えて）ください。  
  （以下、モジュール名を ```cl```、```cf``` と省略表記します）
  * 次の節の「オプション情報の定義」内で、```cf```内の関数が必要でなければ、```cf```の importは不要です。

<br>
<br>

### オプション情報の定義
```py
options = [
        ("#オプション一覧"),
        ("help", "-h, --help", "使い方を表示する"),
        ("all", "-a, --all", "すべて出力"),
        ("name", "-n, --name", "使用者名を指定する//<名前>", str),
        ("count", "-c, --count", "数量を指定する//<数(整数)>", int),
        ("date", "-d, --date", "対象日//<YYYY/M/D>", cf.strptime('%Y/%m/%d')),
]
```

  * 最初の「行」はコメント行です。
  * 続く５行で、５つの「オプション」を定義しています。
  * 最初の２行は、オプション引数を持たないオプションです。
  * 下の３行は、それぞれ「str型」「int型」「モジュール ```cf``` で定義されている関数で返す型」のオプション引数を持つオプションです。
  * 各「オプション」の定義の最初の項目は「オプション名」で、ユーザープログラム内から、コマンドラインで指定された「オプション情報」を参照するときに使います。
  * ３番目の項目は「オプションのコメント」です。不要の場合は省略（続く項目が無い場合）または None、空文字列などを指定してください。
  * あとは、だいたい見た通り（？）の項目で、詳細は別途説明書を参照してください。
  
<br>
<br>

### cl_parse 呼び出し（コマンドラインの解析）
```py
ps = cl.Parse(sys.argv, options, emessage_header="@stem", debug=True)
```
  * 解析対象のコマンドライン（sys.argv）、オプション情報の定義（options）を指定して、```cl.Parse```を呼び出すことによりコマンドラインを解析、解析情報を格納したインスタンス（ここでは ```ps```）を返します。
  * ```cl.Parse``` のその他の引数は、別途説明します。
  
<br>
<br>

### 入力エラー時の処理
```py
if ps.is_error:
    print(ps.get_errormessage(1), file=sys.stderr)
    print(file=sys.stderr)
    for line in ps.get_optionlist():
        print(line, file=sys.stderr)
    exit(1)
```

  * 本モジュールでは、入力エラー時の処理はユーザープログラム側に任されます。
  * ```cl.Parse``` 呼び出し後、入力エラーを検出すると ```ps.is_error``` プロパティが True に設定されます。ユーザープログラムは、このプロパティを参照して、エラー時の処理を行ってください。
  * 上記例では、```ps.is_error``` プロパティが Trueの時（入力エラーが発生した時）に、  
    - ```ps.get_errormessage() ``` メソッドでエラーメッセージを取得して ```stderr``` に出力
    - その次に、```ps.get_optionlist() ``` メソッドでオプション情報リストを取得して ```stderr``` に出力
    - 最後に、```exit(1) ``` でエラー終了しています。
  * 出力結果は、前記「実行例３（入力エラー）」のようになります。
  
<br>
<br>

### help情報指定時の処理
```py
if ps.OPT_help.isEnable:       # 使い方を表示する
    print("これは cl_parse のサンプルプログラムです。\n")
    for line in ps.get_optionlist():
        print(line)
    exit()
```

  * help情報指定時（本サンプルプログラムでは、-h、または --helpが指定された時）の処理も、ユーザープログラム側に任されます。
  * オプション名「help」として定義されたオプション文字列が指定された場合、


---

```py
# 解析エラー時の処理は自前で行う
if ps.is_error:
    print(ps.get_errormessage(1), file=sys.stderr)
    print()
    print("オプション一覧", file=sys.stderr)
    cl.tabprint(ps.get_optionlist(), file=sys.stderr)
    exit(1)
```

<br>

## 解析エラー時の処理

  - 解析エラー時には、 *\<Parse\>.* **is_error** プロパティが **True** になります。  
    その後の動作（エラーメッセージ等の表示とか、プログラムの停止とか）はユーザープログラム側に任されます。
  - 解析エラーの理由は、*\<Parse\>.* **get_errormessage()** メソッドで取得できます。
  - ここでオプション情報を表示したいときは、定義されたオプション情報の一覧を、*\<Parse\>.* **get_optionlist()** メソッドで取得することができます。
  - 上記プログラム例で、 *\<cl_parse\>.* **tabprint()** は、一覧表を表示するためのサービス関数です。
  - 通常は、ここでエラー終了します。

<br>

---

```py
# help情報の表示も自前
if ps.OPT_help.isEnable:       # 使い方を表示する
    print("これは cl_parse のサンプルプログラムです。\n")
    print("オプション一覧")
    cl.tabprint(ps.get_optionlist())
    exit()
```

<br>

## helpメッセージの表示

  - helpオプション（-h、--help）の設定、helpオプションが指定された場合の helpメッセージの表示も、ユーザープログラム側で行います。
  - helpオプションが指定された時の判断方法（上記リスト中の *\<Parse\>.* **OPT_help.isEnable**プロパティを使用している部分）は、次項の記述を参照してください。
  - オプション情報の一覧の取得や表示は、前項の記述を参照してください。

<br>

---


```py
# 解析結果
if ps.OPT_all.isEnable:        # すべて出力
    print("オプション 'all' が指定されました。")

if ps.OPT_name.isEnable:       # 使用者名を指定する
    print("オプション 'name' が指定されました。")
    print(f'    {ps.OPT_name.value=}')
    print()

if ps.OPT_count.isEnable:       # 数量を指定する
    print("オプション 'count' が指定されました。")
    print(f'    {ps.OPT_count.value=}')
    print()

if ps.OPT_date.isEnable:       # 対象日
    print("オプション 'date' が指定されました。")
    print(f'    {ps.OPT_date.value=}')
    print()

if len(ps.params):
    print("以下のコマンド引数が入力されました。")
    print(ps.params)
```


<br>

## 解析結果の取得

  - 定義したオプションが認識されると、 *\<Parse\>.* **OPT_\<オプション名\>** 属性が設定されます。
  - コマンドラインで該当のオプションが指定されると、*\<Parse\>.* **OPT_\<オプション名\>.isEnable** プロパティが **True**に設定されます。（指定されないと、初期値 = **False**のまま）
  - オプション引数が指定されると、*\<Parse\>.* **OPT_\<オプション名\>.value** プロパティにその値が設定されます。（オプションが指定されない場合、及びオプション引数が省略された場合は、初期値 = **None** のまま）
  - *\<Parse\>.* **OPT_\<オプション名\>.value** の型（type）は、オプション情報で定義されたものに対応します。  

<br>

  - コマンド引数は、*\<Parse\>.* **params** プロパティに文字列のリストとして格納されます。
  - パーサーの呼び出しで sys.argv を用いる場合、先頭のプログラム名もコマンド引数として格納されますので、不都合がある場合は sys.argv[1:] のように、プログラム名をとばして指定してください。


<br>
<br>
<br>
<br>


# 超簡易版のサンプルプログラムと実行例
## サンプルプログラム（sample01.pas）

```Python :sample01.py
import sys
from lib import cl_parse as cl
from lib import cl_parse_functions as cf


args = sys.argv
# 試験用コマンドライン
if len(args) <= 1:
    args = 'this.py -a ABC --name=私だ  --date 2021/10/3 # ---#'.split()

options = [
        ["help", "-h, --help", "使い方を表示する", None],
        ["all", "-a, --all", "すべて出力"],
        ["name", "-n, --name", "使用者名を指定する//<名前>", str],
        ["count", "-c, --count", "数量を指定する//<数(整数)>", int],
        ["date", "-d, --date", "対象日//<年/月/日>", cf.strptime('%Y/%m/%d')],
]

# cl_parse 呼び出し（解析実行）
ps = cl.Parse(args, options, emessage_header="@stem", debug=True)

# 解析エラー時の処理は自前で行う
if ps.is_error:
    print(ps.get_errormessage(1), file=sys.stderr)
    print()
    print("オプション一覧", file=sys.stderr)
    cl.tabprint(ps.get_optionlist(), file=sys.stderr)
    exit(1)

# help情報の表示も自前
if ps.OPT_help.isEnable:       # 使い方を表示する
    print("これは cl_parse のサンプルプログラムです。\n")
    print("オプション一覧")
    cl.tabprint(ps.get_optionlist())
    exit()

# 解析結果
if ps.OPT_all.isEnable:        # すべて出力
    print("オプション 'all' が指定されました。")

if ps.OPT_name.isEnable:       # 使用者名を指定する
    print("オプション 'name' が指定されました。")
    print(f'    {ps.OPT_name.value=}')
    print()

if ps.OPT_count.isEnable:       # 数量を指定する
    print("オプション 'count' が指定されました。")
    print(f'    {ps.OPT_count.value=}')
    print()

if ps.OPT_date.isEnable:       # 対象日
    print("オプション 'date' が指定されました。")
    print(f'    {ps.OPT_date.value=}')
    print()

if len(ps.params):
    print("以下のコマンド引数が入力されました。")
    print(ps.params)

```

<br>

## **実行例**

```text
> python3 sample01.py -a --name=わたし --date=2022/2/14 -c 12 ABC XYZ
オプション 'all' が指定されました。
オプション 'name' が指定されました。
    ps.OPT_name.value='わたし'

オプション 'count' が指定されました。
    ps.OPT_count.value=12

オプション 'date' が指定されました。
    ps.OPT_date.value=datetime.datetime(2022, 2, 14, 0, 0)

以下のコマンド引数が入力されました。
['sample01.py', 'ABC', 'XYZ']
> 
```

<br>
<br>
<br>
<br>

# もう少し詳しい説明
## オプション情報

下記のように４項目からなるリストを１オプション分の定義情報とし、オプション数分のリストで１組のオプション情報とする。
```
option = [
    [＜第１項目＞, ＜第２項目＞, ＜第３項目＞, ＜第４項目＞], 
    ..... ,
    ..... ,
]
```

| 項目     | 型            | 内容                                           |
| -------- | ------------- | ---------------------------------------------- |
| 第１項目 | str（文字列） | オプション名                                   |
| 第２項目 | str（文字列） | オプション文字列（複数の場合は , で区切る）    |
| 第３項目 | str（文字列） | オプションのコメント                           |
| 第４項目 | いろいろ      | オプション、オプション引数の「振る舞い」の定義 |

<br>

---
### **オプション名**
  - "help"、"all"、"date" など、オプションの「名前」を文字列で定義します。
  - 文字列は、Pythonの変数名に使用できる文字のみが使用できます。
  - オプション名は、プログラム内でオプションの識別のために使用されます。

<br>

### **オプション文字列**
  - ”-h, --help"、"-d, --date" など、実際にコマンド文字列で入力する文字列を定義します。
  - 一つのオプションに対し、複数のオプション文字列をカンマ（,）で区切って定義することができます。
  - 同一のオプションに、１文字オプション文字列、ロング名オプション文字列を両方定義したり、片方のみを定義することもできます。
  - １文字オプション文字列は、ハイフン（-）に続く英数字１文字の文字列で定義します。本モジュールでは英数字以外に 「-?」 も許容します。  
   　ex)　-a、-b、-9、 -?　など
  - ロング名オプション文字列は、２つのハイフン（--）に続く英数字、ハイフン（-）で構成される文字列で定義します。本モジュールでは、アンダーバー（_）も許容します。ただし、文字列の最後のハイフン（-）は許容しません。  
   　ex)　--version、--display-size、--audio_contorol　など

<br>

### **オプションのコメント**
  - オプションのコメントを定義します。
  - オプション引数のコメントを併記するときは、２つのスラッシュ（//）で区切って定義します。
  - このコメントは、オプション一覧、ユーティリティ機能でテンプレートを出力したときのコメントで使用されます。コマンドライン解析自体には（あっても無くても）影響しません。
  - オプションのコメントが不要な時は、空文字列（""）を指定してください。

<br>

### **オプション、オプション引数の「振る舞い」の定義**
  - ここには、アクション（オプションが指定された時の振る舞い）を指定する文字列や、呼び出し可能オブジェクト（オプション引数の変換用関数）を記述します。列挙型クラスを記述することもできます。
  - 複数の指定を記述するときは、タプル、またはリストにします。単独の指定のときはタプル、またはリストにしても、そのまま記述してもかまいません。
  - オプション引数を持たず、ただ「指定されたかどうか」だけを判断するオプションは、**None** を指定するか、この項目自体を省略します。

<br>

  - アクションを指定する文字列は、以下のものがあります。

| アクション文字列 | アクション内容                   | 他のアクションと併用 | 変換用関数、または列挙型との併用 |
| ---------------- | -------------------------------- | -------------------- | -------------------------------- |
| 指定なし         | オプション引数の値を格納         | --                   | 必要                             |
| "OPTIONAL"       | オプション引数を省略可能         | APPEND と併用可      | 可、省略時は strと同じ           |
| "APPEND"         | オプション引数の値をリストに格納 | OPTIONAL と併用可    | 可、省略時は strと同じ           |
| "COUNT"          | オプション指定の回数を取得       | 不可                 | 不可                             |

<br>
<br>

  - 変換用関数として、以下のような組み込み関数が使えます。

| 組み込み関数 | 機能                                           |
| ------------ | ---------------------------------------------- |
| str          | オプション引数をそのまま格納（変換はしません） |
| int          | 整数に変換して格納                             |
| float        | 浮動小数点数に変換して格納                     |


<br>

  - cl_parse（cl_parse_functions） で定義している変換用関数は、以下のものがあります。
  - 利用のためには、lib/cl_parse_functions を importする必要があります。

| cl_parse_functions で定義している関数                               | 機能                                                                         |
| ------------------------------------------------------------------- | ---------------------------------------------------------------------------- |
| \<cl_parse_functions\>.int_literal                                  | 整数リテラル（"0x04FF" とか）を整数に変換                                    |
| \<cl_parse_functions\>.date                                         | <年>/<月>/<日> の形式の文字列を datetime型に変換して格納                     |
| \<cl_parse_functions\>.strptime(format)                             | 指定したformatで、文字列を datetime型に変換して格納                          |
| \<cl_parse_functions\>.str_choices(文字列リスト)                    | 文字列リストにある文字列であれば格納、無ければエラー                         |
| \<cl_parse_functions\>.sepalate_items(変換関数, セパレータ, item数) | 文字列を指定のセパレータで分割、各項目を指定の変換関数で変換してリストに格納 |

<br>

  - 列挙型クラスとして、以下のものを指定可能です。

| 列挙型クラス      | 機能                                                                                                                       |
| ----------------- | -------------------------------------------------------------------------------------------------------------------------- |
| Enum型、IntEnum型 | 属性値に相当する文字列を、指定の型の属性値に変換して格納                                                                   |
| Flag型、IntFlag型 | 属性値に相当する文字列を、指定の型の属性値に変換して格納。<br>オプション引数文字列に、or演算子（ \| ）を使うことができます |

<br>
<br>

  - 変換用関数は、以下の条件を満たしている必要があります。
      * オプション引数（文字列）を入力(関数の引数）とする。
      * 解釈結果を出力とする。
      * 解釈エラー（変換エラー）時は、適切な例外を raiseする。
  - 上記の条件を満たす関数であれば、ユーザー側で作成したものも使用することができます。  
    本モジュールでは、ユーザーが変換用関数を作成するための補助関数も用意しています。（説明は別途）

<br>

  - 「振る舞い」の定義の例
     * **None**、または省略
       - オプション引数なし、オプションが指定されたかどうかだけを取得する。
       - オプションが指定された場合は、*\<option\>.* **OPT_\<オプション名\>.isEnable** がTrueに設定される。
       - *\<option\>.* **OPT_\<オプション名\>.value** は初期値=None のまま変わらない。  
     * "COUNT"
       - オプションが指定された回数のみを取得する。
       - オプションが指定された場合は、*\<option\>.* **OPT_\<オプション名\>.isEnable** がTrueに設定される。
       - *\<option\>.* **OPT_\<オプション名\>.value** に指定された回数が入る。  
     * str
       - オプション引数をそのまま（文字列のまま）格納する。
       - オプションが指定された場合は、*\<option\>.* **OPT_\<オプション名\>.isEnable** がTrueに設定される。
       - *\<option\>.* **OPT_\<オプション名\>.value** に指定されたオプション引数が入る。  
     * int
       - オプション引数を整数に変換して格納する。
       - オプションが指定された場合は、*\<option\>.* **OPT_\<オプション名\>.isEnable** がTrueに設定される。
       - *\<option\>.* **OPT_\<オプション名\>.value** に変換された整数が入る。変換できないときは入力エラーになる。  
     * ("OPTIONAL", int, float )
       - オプション引数を整数、または浮動小数点数に変換して格納する。整数に変換できないときは浮動小数点数に変換し、どちらにも変換できないときは入力エラーになる。
       - オプションが指定された場合は、*\<option\>.* **OPT_\<オプション名\>.isEnable** がTrueに設定される。
       - *\<option\>.* **OPT_\<オプション名\>.value** に変換された整数（int型）、または浮動小数点数（float型）が入る。変換できないときは入力エラーになる。  
       - オプション引数省略時は、*\<option\>.* **OPT_\<オプション名\>.value** に None （初期値と同じ値）が入る。








