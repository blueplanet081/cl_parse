<!-- omit in toc -->
# cl_parse -- コマンドラインパーサー
<!-- omit in toc -->
## 内容
- [概要](#概要)
  - [紹介](#紹介)
  - [動作環境](#動作環境)
  - [作成経緯](#作成経緯)
  - [特徴（宣伝）](#特徴宣伝)
  - [**ファイル構成**](#ファイル構成)
  - [**履歴**](#履歴)
- [プログラム例](#プログラム例)
  - [サンプルプログラム（sample01.py）](#サンプルプログラムsample01py)
    - [実行例１](#実行例１)
    - [実行例２](#実行例２)
    - [実行例３（入力エラー時）](#実行例３入力エラー時)
  - [サンプルプログラムの中身の説明](#サンプルプログラムの中身の説明)
    - [cl_parseモジュールのimport](#cl_parseモジュールのimport)
    - [オプション情報の定義](#オプション情報の定義)
    - [cl_parse 呼び出し（コマンドラインの解析）](#cl_parse-呼び出しコマンドラインの解析)
    - [入力エラー時の処理](#入力エラー時の処理)
    - [help情報指定時の処理](#help情報指定時の処理)
    - [各オプション指定時の処理（オプションが指定されたかどうか）](#各オプション指定時の処理オプションが指定されたかどうか)
    - [各オプション指定時の処理（オプション引数の取得）](#各オプション指定時の処理オプション引数の取得)
    - [コマンド引数の取得](#コマンド引数の取得)

<br>

# 概要
## 紹介
Pythonで記述するデスクトップ・プログラムに組み込んで使うもので、コマンドラインのオプション、オプション引数を解析するメソッドを提供します。  
<br>

## 動作環境

 * Python 3.8以降で動きます。
   - 作成と主なテストは Python 3.8 を使用しています。
   - 3.7 でも動くと思いますが、テストしていません。
   - Enum や、新しい型ヒントなどを使っているので、3.6より古い環境では動きません。
 * Windows10/11のPowerSheel、UbuntuのBash、MacOSのBash/zsh上で動作を確認しています。

<br>

## 作成経緯

  - CLIベースのコマンドを試作／製作するとき、起動オプションの処理を手軽に記述したかった。
  - 標準ライブラリ argparseの仕様を一部参考にした部分もありますが、もともとこのライブラリの使い方が分からなかった（私には難解だった）ので、もっと簡単なものを、と思って作っています。
  - Python学習も兼ねてます。  

<br>

## 特徴（宣伝）

   - オプション情報を１オプションにつき１行の組（タプル）で定義するだけなので、手軽に見通し良く利用できます。
   - オプションが引数を持つ場合、引数は解析時に指定のデータ型に変換されるので、ユーザープログラム内で容易に（改めて変換したり、型チェックをすることなく）使えます。
   - オプション引数のデータ型、変換方法は、ユーザー側で定義を追加することができます。（補助関数があります）
   - 入力エラー時は、エラーメッセージ文字列とともにステータスが設定されます。その後の動作はユーザープログラム（呼び出し側のプログラム）に任されます。（argparseと最も違うところかも？）
   - エラーメッセージ文字列は、ユーザー側で再定義可能です。
   - usage:を自動作成したり、help指定時に自動的に表示したりする機能はありませんが、オプション一覧をそれなりに生成する機能があります。
   - Windows環境では、解析に先立ってワイルドカード展開、~展開をします。Unix/Linux上と似たような動きで使えます。（ブレース展開は現段階ではサポートしていません）
   - コマンドラインの指定により、オプション情報の設定内容や解析結果などを表示するデバッグ機能や、ユーザープログラム内でオプション情報を取得するためのコードを生成する補助機能があります。

<br>

## **ファイル構成**

| ファイル名                    | 内容                                                       |
| ----------------------------- | ---------------------------------------------------------- |
| lib/cl_parse.py               | cl_parse本体（使うのに必要なのはこのファイルだけです）     |
| lib/cl_parse_functions.py     | cl_parse用変換関数                                         |
| lib/cl_parse_debugmodule.py   | cl_parse用デバッグモジュール                               |
| ----------------------------- | --------------------------------------------------------   |
| README.md                     | このドキュメント                                           |
| options.md                    | コマンドラインの構成とか、言葉の定義とか                   |
| sample01.py                   | 一番シンプルなサンプル                                     |
| ptree.py                      | miniparse使用サンプル。いわゆる treeコマンドの試作版です。 |
| e2_path.py                    | ptree.pyが呼び出している自作ライブラリ（添付用簡易版）     |

<br>

## **履歴**

| バージョン | 日付      | 変更箇所 | コメント     |
| ---------- | --------- | -------- | ------------ |
| 1.0.0      | 2022/3/23 |          | いちおう完成 |


<br>


# プログラム例
## サンプルプログラム（sample01.py）

``` py
# sample01.py  for cl_parse module
import sys
from lib import cl_parse as cl
from lib import cl_parse_functions as cf


# オプション情報の定義
options = [
        ("#オプション一覧"),
        ("help", "-h, --help", "使い方を表示する"),
        ("all", "-a, --all", "すべて出力"),
        ("name", "-n, --name", "使用者名を指定する//<名前>", str),
        ("count", "-c, --count", "数量を指定する//<数(整数)>", int),
        ("date", "-d, --date", "対象日//<YYYY/M/D>", cf.strptime('%Y/%m/%d')),
]

# cl_parse 呼び出し（コマンドラインの解析）
ps = cl.Parse(sys.argv, options, emessage_header="@stem", debug=True)

# 入力エラー時の処理
if ps.is_error:
    print(ps.get_errormessage(1), file=sys.stderr)
    print(file=sys.stderr)
    for line in ps.get_optionlist():
        print(line, file=sys.stderr)
    exit(1)

# help情報指定時の処理
if ps.OPT_help.isEnable:       # 使い方を表示する
    print("これは cl_parse のサンプルプログラムです。\n")
    for line in ps.get_optionlist():
        print(line)
    exit()

# 以下、ユーザープログラムの処理 ---------------------------
# 各オプション指定時の処理
if ps.OPT_all.isEnable:        # すべて出力
    print("オプション 'all' が指定されました。")

if ps.OPT_name.isEnable:       # 使用者名を指定する
    print("オプション 'name' が指定されました。")
    print(f'    {ps.OPT_name.value = }')
    print()

if ps.OPT_count.isEnable:       # 数量を指定する
    print("オプション 'count' が指定されました。")
    print(f'    {ps.OPT_count.value = }')
    print()

if ps.OPT_date.isEnable:       # 対象日
    print("オプション 'date' が指定されました。")
    print(f'    {ps.OPT_date.value = }')
    print()

# コマンド引数の取得
if len(ps.params):
    print("以下のコマンド引数が入力されました。")
    print(ps.params)
```

### 実行例１
```txt
> python3 sample01.py -h
これは cl_parse のサンプルプログラムです。

オプション一覧
-h, --help      : 使い方を表示する
-a, --all       : すべて出力
-n, --name <名前>       : 使用者名を指定する
-c, --count <数(整数)>  : 数量を指定する
-d, --date <YYYY/M/D>   : 対象日
```

### 実行例２
```txt
> python3 sample01.py --name=Taro --date=2022/4/1 SAMPLE
オプション 'name' が指定されました。
    ps.OPT_name.value = 'Taro'

オプション 'date' が指定されました。
    ps.OPT_date.value = datetime.datetime(2022, 4, 1, 0, 0)

以下のコマンド引数が入力されました。
['sample01.py', 'SAMPLE']
```

### 実行例３（入力エラー時）
```txt
> python3 sample01.py --name=Taro --date=2022/4/ SAMPLE
sample01 E12: illegal argument specified for option --date=2022/4/
  -- time data '2022/4/' does not match format '%Y/%m/%d'

オプション一覧
-h, --help      : 使い方を表示する
-a, --all       : すべて出力
-n, --name <名前>       : 使用者名を指定する
-c, --count <数(整数)>  : 数量を指定する
-d, --date <YYYY/M/D>   : 対象日
```
<br>
<br>

## サンプルプログラムの中身の説明
### cl_parseモジュールのimport
```py
import sys
from lib import cl_parse as cl
from lib import cl_parse_functions as cf
```

  * ここでは、cl_parseモジュールが ```./lib``` ディレクトリ内にあることを想定しています。
  * ```cl``` とか ```cf``` とかの「別名」はお好みで読み替えて（付け替えて）ください。  
  （以下、モジュール名を ```cl```、```cf``` と省略表記します）
  * 次の節の「オプション情報の定義」内で、```cf```内の関数が必要でなければ、```cf```の importは不要です。

<br>

### オプション情報の定義
```py
# オプション情報の定義
options = [
        ("#オプション一覧"),
        ("help", "-h, --help", "使い方を表示する"),
        ("all", "-a, --all", "すべて出力"),
        ("name", "-n, --name", "使用者名を指定する//<名前>", str),
        ("count", "-c, --count", "数量を指定する//<数(整数)>", int),
        ("date", "-d, --date", "対象日//<YYYY/M/D>", cf.strptime('%Y/%m/%d')),
]
```

  * 最初の「行」はコメント行です。
  * 続く５行で、５つの「オプション」を定義しています。
  * 最初の２行は、オプション引数を持たないオプションです。
  * 下の３行は、それぞれ「str型」「int型」「モジュール ```cf``` で定義されている関数で返す型」のオプション引数を持つオプションです。
  * 各「オプション」の定義の最初の項目は「オプション名」で、ユーザープログラム内から、コマンドラインで指定された「オプション情報」を参照するときに使います。
  * ３番目の項目は「オプションのコメント」です。不要の場合は省略（続く項目が無い場合）または None、空文字列などを指定してください。
  * あとは、だいたい見た通り（？）の項目なので、詳細は別途説明書を参照してください。
  
<br>

### cl_parse 呼び出し（コマンドラインの解析）
```py
# cl_parse 呼び出し（コマンドラインの解析）
ps = cl.Parse(sys.argv, options, emessage_header="@stem", debug=True)
```
  * 解析対象のコマンドライン（sys.argv）、オプション情報の定義（options）を指定して、```cl.Parse```を呼び出すことによりコマンドラインを解析、解析情報を格納したインスタンス（ここでは ```ps```）を返します。
  * ```cl.Parse``` のその他の引数は、別途説明します。
  
<br>

### 入力エラー時の処理
```py
# 入力エラー時の処理
if ps.is_error:
    print(ps.get_errormessage(1), file=sys.stderr)
    print(file=sys.stderr)
    for line in ps.get_optionlist():
        print(line, file=sys.stderr)
    exit(1)
```

  * 本モジュールでは、入力エラー時の処理はユーザープログラム側に任されます。
  * ```cl.Parse``` 呼び出し後、入力エラーを検出すると ```ps.is_error``` プロパティが True に設定されます。ユーザープログラムは、このプロパティを参照して、エラー時の処理を行ってください。
  * 上記例では、```ps.is_error``` プロパティが Trueの時（入力エラーが発生した時）に、  
    - ```ps.get_errormessage() ``` メソッドでエラーメッセージを取得して ```stderr``` に出力
    - その次に、```ps.get_optionlist() ``` メソッドでオプション情報リストを取得して ```stderr``` に出力
    - 最後に、```exit(1) ``` でエラー終了しています。
  * 上記サンプルの出力結果は、前記「実行例３（入力エラー）」のようになります。
  
<br>

### help情報指定時の処理
```py
# help情報指定時の処理
if ps.OPT_help.isEnable:       # 使い方を表示する
    print("これは cl_parse のサンプルプログラムです。\n")
    for line in ps.get_optionlist():
        print(line)
    exit()
```

  * help情報指定時（本サンプルプログラムでは、-h、または --helpが指定された時）の処理も、ユーザープログラム側に任されます。
  * コマンドラインで、オプション名「help」に対するオプション文字列が指定されると、```cl.Parse``` のインスタンス ```ps``` のアトリビュート 「```OPT_help```」のプロパティ「```OPT_help.isEnable```」が **TRUE** になります。ユーザープログラムでは、この状態を判断して、helpに対応する処理を行います。
  * 上記例では、「```"これは cl_parse のサンプルプログラムです。\n"``` 」のメッセージを表示した後、```ps.get_optionlist() ``` メソッドでオプション情報リストを取得して表示、プログラムを終了しています。
  * 上記サンプルの出力結果は、前記「実行例１」のようになります。

<br>

### 各オプション指定時の処理（オプションが指定されたかどうか）
※ 以下は、コマンドラインで指定されたオプションに対応した、ユーザープログラム固有の処理になります。
```py
# 以下、ユーザープログラムの処理 ---------------------------
# 各オプション指定時の処理
if ps.OPT_all.isEnable:        # すべて出力
    print("オプション 'all' が指定されました。")
```

  * オプション情報を定義すると、```cl.Parse``` のインスタンス ```ps``` に、そのオプション情報にアクセスするためのアトリビュート「```OPT_```*<オプション名>*」が作成されます。ここでは、オプション名「all」に対して、アトリビュート ```OPT_all``` が作成されています。  
  （前記の「help情報」の場合と同じです）
  * コマンドラインで、そのオプションに対するオプション文字列が指定されると、「```OPT_```*<オプション名>*```.isEnable```」が **True**になります。

<br>

### 各オプション指定時の処理（オプション引数の取得）
```py
if ps.OPT_name.isEnable:       # 使用者名を指定する
    print("オプション 'name' が指定されました。")
    print(f'    {ps.OPT_name.value = }')
    print()

if ps.OPT_count.isEnable:       # 数量を指定する
    print("オプション 'count' が指定されました。")
    print(f'    {ps.OPT_count.value = }')
    print()

if ps.OPT_date.isEnable:       # 対象日
    print("オプション 'date' が指定されました。")
    print(f'    {ps.OPT_date.value = }')
    print()
```

  * オプション引数は、オプション情報定義に対応する「型」に変換されて、「```OPT_```*<オプション名>*```.value```」に格納されます。オプション引数が無い場合、省略された場合は、この値は **None** になります。
  * 上記サンプルの出力結果は、前記「実行例２」のようになります。

<br>

### コマンド引数の取得
```py
# コマンド引数の取得
if len(ps.params):
    print("以下のコマンド引数が入力されました。")
    print(ps.params)
```

  * コマンド引数は、```ps.params``` プロパティで取得します。コマンド引数（文字列）のリストになります。
  * 上記サンプルの出力結果は、前記「実行例２」のようになります。
  * 本モジュールでは、```cl.Parse``` 呼び出し時の第１パラメーターに「```sys.argv```」を指定した場合、```sys.argv```の先頭の「プログラム名」も「先頭のコマンド引数」として認識します。これが不都合な場合は、第１パラメーターに「```sys.argv[1:]```」のように、先頭のプログラム名を除いたものを指定してください。

